<!DOCTYPE html>
<html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="style.css">
<body>
    <script src="http://d3js.org/d3.v4.min.js"></script>
    <script>

        //globals
        var margin = {top: 10, right: 10, bottom: 10, left: 10},
            width = 800 - margin.left - margin.right,
            height = 600 - margin.top - margin.bottom,
            header = 20,
            innerheight = height - header,
            linePadding = 20,
            dataset;

        // pull in the data
        var datasource = d3.json("data.json",function(error,data){
            if (error) return console.warn(error);
            dataset = data;
            
            //Adapt data to visualisation
            dataset = orderByRank(dataset)
            dataset = orderByDescendingYear(dataset)
            
            // build the chart once the data are loaded
            buildChart();
        });

        //Function to order regions by ascending rank into each year
        function orderByRank(data){
            data.forEach(function(oneYear, index){
                oneYear.regions.sort(function(a, b){
                    return b.diff-a.diff
                })
            })
            return data;
        }
        
        //Function to order years by descending order
        function orderByDescendingYear(data){
            data.sort(function(a,b){
                return parseInt(b.year)-parseInt(a.year)
            })
            return data
        }
        
        //Main function to build Rank chart
        function buildChart(){
            
            var regionsPerYear = []
            dataset.forEach(function(record, idx){
                regionsPerYear.push(record.regions)
            })
            
            var metricwidth = width / regionsPerYear.length;

            // create the lines from the index values
            var pathfunction = function(obj){
                var datavals = obj.data,
                    dataLen = datavals.length,
                    // new array to store the x/y pairs to build the 'plateaus'
                    newArray = [];
                datavals.forEach(function(d,i){
                    var x1,y1,x2,y2;
                    // if the value isn't null
                    if ( d !== null) {
                        x1 = metricwidth * i + linePadding; 
                        y1 = header + (innerheight / obj.len) * (d + 1);
                        x2 = metricwidth * i + metricwidth - linePadding;
                        y2 = header + (innerheight / obj.len) * (d + 1);
                        newArray.push({x:x1,y:y1});
                        newArray.push({x:x2,y:y2});
                    } else {
                        // blank space in line if null value...
                        x1 = y1 = x2 = y2 = null;
                        newArray.push({x:x1,y:y1});
                        newArray.push({x:x2,y:y2});
                    }

                });

                var lineFunction = d3.line()
                .defined(function(d) { return d.y != null; }) // no if null
                .x(function(d) { return d.x; })
                .y(function(d) { return d.y; })
                
                // /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\
                //CAUTION HACK -- When straight line doesn't want to be colorized
                //Change a little bit the line to never have straight line
                var retour = lineFunction(newArray)
                    
                for (var i=retour.length-1; i>=0;i--){
                    if (retour[i]==',' || retour[i]==' '){
                        retour = retour.substring(0,i+1) + (parseInt(retour.substring(i+1,retour.length)) -0.0001)
                        break;
                    }
                }
                // /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\ /!\
                
                return retour // send back the line
            }

            var mouseOver = function(selectorclass){
                d3.selectAll('.'+selectorclass+'_line:not(.line-click)')
                .classed('line-no-accent', false)
                .classed('line-accent', true)
                d3.selectAll('.'+selectorclass+'_text:not(.label-click)')
                .classed('label-no-accent', false)
                .classed('label-accent', true)
            }
            var mouseOut = function(selectorclass){
                d3.selectAll('.'+selectorclass+'_line:not(.line-click)')
                .classed('line-accent', false)
                .classed('line-no-accent', true)
                d3.selectAll('.'+selectorclass+'_text:not(.label-click)')
                .classed('label-no-accent', true)
                .classed('label-accent', false)
            }
            var click = function(selectorclass){
                d3.selectAll('.line-click')
                .classed('line-click', false)
                .classed('line-accent', false)
                .classed('line-no-accent', true)
                d3.selectAll('.label-click')
                .classed('label-click', false)
                .classed('label-accent', false)
                .classed('label-no-accent', true)
                d3.selectAll('.'+selectorclass+'_line')
                .classed('line-click', true)
                d3.selectAll('.'+selectorclass+'_text')
                .classed('label-click', true)
            }
            var rectSlide = function(idx){
                var rect = d3.select("rect");
                rect.transition()
                .attr("x", (metricwidth * idx));
            }

            var lineHeader = d3.select("body")
            .append("svg")
            .classed("titleHeader", true)
            .selectAll('.lineHeader')
            .data(dataset[0].regions)
            .enter()
            .append("text")
            .classed("lineHeader", true)
            .attr("x", function(d, idx){
                return 0;
            })
            .attr("y", function(d, idx){
                return header + (innerheight / dataset[0].regions.length) * (idx + 1);
            })
            .text(function(d,i){
                return d.name
            })
            
            var svg = d3.select("body")
            .append("svg")
            .attr("class","viz")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom);

            //Draw the Rectangle
            var rectangle = svg.append("rect")
            .attr("x", 0)
            .attr("y", margin.top)
            .attr("rx", 10)
            .attr("ry", 10)
            .attr("width", metricwidth)
            .attr("height", height)
            .attr("stroke", "lightgrey")
            .attr("stroke-width",2)
            .attr("fill","white")

            //Store possible regions with his index for each year
            var metriclist = dataset[0].regions;
            var lookup = [];
            metriclist.forEach(function(rec,idx){
                var o = {};
                o.metric = rec.name;
                o.data = [];
                o.diff = rec.diff
                lookup.push(o);
            })

            //Assign to each region his rank for each year 
            dataset.forEach(function(record,index){

                var metric = record.year;
                var vals = record.regions;
                
                vals.forEach(function(rec,idx){
                    
                    lookup.forEach(function(r,i){
                        
                        // if we have a match...
                        if ( r.metric == rec.name ){

                            if (rec.diff != null) {
                                lookup[i].data[index] = idx;

                            } else {
                                lookup[i].data[index] = null;
                            }

                        }
                    })
                })
            })

            // build the lines
            var paths = svg
            .selectAll("paths")
            // bind lookup to lines
            .data(lookup)
            .enter()
            .append("path")
            .attr("class",function(d){ return d.metric.replace(/\s/g,'')+'_line'}) // use class attr to add login to class assignment
            .classed("line", true) // add additional classes with classed
            .classed("line-no-accent", true)
            // call path function on data, passing in array length for y measure
            .attr("d",function(d,i){return pathfunction({len:lookup.length,data:d.data})})
            .attr("stroke", function(d,i){
                return "url(#line"+i+")"
            })
            .on("mouseover", function(d){mouseOver(d.metric.replace(/\s/g,''))})
            .on("mouseout", function(d){mouseOut(d.metric.replace(/\s/g,''))})
            .on("click", function(d){click(d.metric.replace(/\s/g,''))})

            /* ---------- */
            /* Path COLOR */
            /* ---------- */
            var colorDefs = svg.append("defs")
            .selectAll("linearGradient")
            .data(lookup)
            .enter()
            .append("linearGradient")
            .attr("id", function(region, index){
                return "line" + index;
            })
            .attr("x1", "0%")
            .attr("y1", "0%")
            .attr("x2", "100%")
            .attr("y2", "0%")
            
            var regionsWithCurrentDiff = [];
            dataset[0].regions.forEach(function(d,i){
                var obj = {}
                obj.name = d.name
                obj.diff = d.diff
                regionsWithCurrentDiff.push(obj)
            })
            
            
            regionsWithCurrentDiff.forEach(function(r, i){
                
                if (r.diff<0)
                    colorDefs.filter(function(line, l){
                        if (line.metric==r.name)
                            return true
                        else 
                            return false
                    })
                    .append("stop")
                    .attr("offset", "0%")
                    .attr("style", "stop-color:rgb(255,0,0);stop-opacity:1")
                else
                    colorDefs.filter(function(line, l){
                        if (line.metric==r.name)
                            return true
                        else 
                            return false
                    })
                    .append("stop")
                    .attr("offset", "0%")
                    .attr("style", "stop-color:rgb(0,255,0);stop-opacity:1")
            })
            
            dataset.forEach(function(record, i){
                
                var year = record.year;
                var regions = record.regions;
                
                regions.forEach(function(region, j){

                    lookup.forEach(function(r, k){

                        // if we have a match...
                        if ( r.metric == region.name ){
                            
                            if (region.diff < 0 && regionsWithCurrentDiff[k].diff >=0){
                                
                                var def = colorDefs.filter(function(line, l){
                                    if (r.metric==line.metric)
                                        return true
                                    else 
                                        return false
                                })
                                
                                def.append("stop")
                                .attr("offset", ((100/(dataset.length-1))*i)-5+"%")
                                .attr("style", "stop-color:rgb(0,255,0);stop-opacity:1")
                                
                                def.append("stop")
                                .attr("offset", ((100/(dataset.length-1))*i)+"%")
                                .attr("style", "stop-color:rgb(255,0,0);stop-opacity:1")
                                
                                regionsWithCurrentDiff[k].diff = region.diff
                            }
                            else{
                                if (region.diff >= 0 && regionsWithCurrentDiff[k].diff < 0){
                                    
                                    var def = colorDefs.filter(function(line, l){
                                        if (r.metric==line.metric)
                                            return true
                                        else 
                                            return false
                                    })
                                    
                                    def.append("stop")
                                    .attr("offset", ((100/(dataset.length-1))*i)-5+"%")
                                    .attr("style", "stop-color:rgb(255,0,0);stop-opacity:1")
                                    
                                    def.append("stop")
                                    .attr("offset", ((100/(dataset.length-1))*i)+"%")
                                    .attr("style", "stop-color:rgb(0,255,0);stop-opacity:1")

                                    regionsWithCurrentDiff[k].diff = region.diff
                                }
                            }
                            
                            
                        }
                    })
                })
            })
            
            // pull put keys only for headers
            var keys = [];
            dataset.forEach(function(record, idx){
                keys.push(record.year)
            })
            
            var headerText = svg
            .selectAll(".headertext")
            // bind data
            .data(keys)
            .enter()
            .append("text")
            .attr("class","headertext")
            .attr("x", function(key, i){
                return metricwidth * i + linePadding;
            })
            .attr("y", function(key, i){
                return 30;
            })
            .text(function(key, i){
                return key;})
            .on("click", function(d,i){
                d3.selectAll(".topYear")
                .selectAll("h2")
                .data([dataset[i]])
                .text(function(year, i){
                    return "Classement "+year.year
                })
                
                d3.selectAll(".topYear")
                .selectAll("p")
                .data(dataset[i].regions)
                .text(function(d,i){
                    return "#" + (i+1) + "  " + d.name
                })
                
                rectSlide(i);
            })
            
            var textGroup = svg
            .selectAll("textgroup")
            .data(dataset)
            .enter()
            .append("g");
            
            textGroup
            .each(function(record,i){

                var metric = d3.select(this)
                .selectAll("text")
                .data(record.regions)
                .enter()
                .append("text")
                .attr('class',function(d, idx){
                    return d.name.replace(/\s/g,'') + '_text';})
                .classed('label', true)
                .classed("label-no-accent", true)
                .attr("x", function(d, idx){
                    if ( d ) {
                        return metricwidth * i + linePadding;
                    }
                })
                .attr("y", function(d, idx){
                    if ( d ) {
                        return header + (innerheight / record.regions.length) * (idx + 1) - 5;
                    }
                })
                .text(function(d, idx){
                    var rank = idx + 1;
                    if (d.diff != null) {
                        return '#' + String(rank)
                    }
                })
                .on("mouseover", function(d){mouseOver(d.year)})
                .on("mouseout", function(d){mouseOut(d.year)})
                .on("click", function(d){click(d.year)})
                })

            var topYear = d3.select("body")
            .append("div")
            .classed("topYear", true)
            
            topYear.selectAll("h2")
            .data([dataset[0]])
            .enter()
            .append("h2")
            .text(function(year, i){
                console.log(year)
                return "Classement "+year.year
            })
            
            topYear.selectAll("p")
            .data(dataset[0].regions)
            .enter()
            .append("p")
            .text(function(d,i){
                return "#" + (i+1) + "  " + d.name                
            })
        }
    </script>
</body>
</html>